package tsukaiyasui

import (
	"embed"
	"encoding/json"
	"sort"
	"strings"

	"github.com/Lil-Strudel/tsukaiyasui_zmk/keymap_parse"
)

//go:embed adapters/* zmk/*
var fs embed.FS

func tab(tabs int) string {
	return strings.Repeat("    ", tabs)
}

func getLayoutCodes() [][]string {
	adapterBytes, _ := fs.ReadFile("adapters/lily58.yasui")
	adapterLayout := extractYasuiSection(string(adapterBytes), "layout")

	rows := strings.Split(adapterLayout, "\n")

	layoutCodes := make([][]string, len(rows))
	for rowI := range layoutCodes {
		codes := strings.Split(rows[rowI], " ")

		var filteredCodes []string
		for _, code := range codes {
			if code != "___" {
				filteredCodes = append(filteredCodes, code)
			}
		}

		layoutCodes[rowI] = filteredCodes
	}

	return layoutCodes
}

func generateKeymap(bindings [][]string, layout [][]string) map[string]string {
	keymap := make(map[string]string)

	for i, row := range layout {
		for j, key := range row {
			keymap[key] = bindings[i][j]
		}
	}

	return keymap
}

type Layer struct {
	Identifier     string
	Order          int
	Label          string
	Bindings       string
	SensorBindings string
}

func GenerateKeymap(shield string) string {
	validateShield(shield)

	file, ok := fs.Open("zmk/base.keymap")
	if ok != nil {
		panic("Could not read file")
	}

	coreKeymap := keymap_parse.ParseKeymap(file)

	layoutCodes := getLayoutCodes()

	adapterBytes, _ := fs.ReadFile("adapters/" + shield + ".yasui")
	adapterLayout := extractYasuiSection(string(adapterBytes), "layout")

	rows := strings.Split(adapterLayout, "\n")

	layers := make([]Layer, 0)

	for key, value := range coreKeymap.RootNode.Keymap.Layers {
		keymap := generateKeymap(value.Bindings, layoutCodes)

		longestKeymap := make(map[int]int)
		adaptedKeymap := make([][]string, len(rows))
		for rowI := range adaptedKeymap {
			adaptedKeymap[rowI] = strings.Split(rows[rowI], " ")
			for keyI, keyCode := range adaptedKeymap[rowI] {
				var thisKeymap string
				if keyCode == "___" {
					thisKeymap = ""
				} else {
					keymap, ok := keymap[keyCode]
					if ok {
						thisKeymap = keymap
					} else {
						thisKeymap = "&none"
					}
				}

				adaptedKeymap[rowI][keyI] = thisKeymap

				if longestKeymap[keyI] < len(thisKeymap) {
					longestKeymap[keyI] = len(thisKeymap)
				}
			}
		}

		joinedAdaptedKeymap := make([]string, len(adaptedKeymap))
		for rowI := range adaptedKeymap {
			for keyI, key := range adaptedKeymap[rowI] {
				spacesToAdd := longestKeymap[keyI] - len(key)
				if spacesToAdd > 0 {
					adaptedKeymap[rowI][keyI] = key + strings.Repeat(" ", spacesToAdd)
				}
			}

			joinedAdaptedKeymap[rowI] = strings.Join(adaptedKeymap[rowI], "  ")
		}

		layers = append(layers, Layer{Identifier: key, Label: value.DisplayName, Bindings: strings.Join(joinedAdaptedKeymap, "\n"), Order: value.Order})
	}
	sort.Slice(layers,
		func(i, j int) bool {
			return layers[i].Order < layers[j].Order
		})

	keymapString := "// Generated by Tsukaiyasui\n"
	for i := 0; i < len(coreKeymap.Includes); i++ {
		keymapString += "#include <" + coreKeymap.Includes[i] + ">\n"
	}

	keymapString += "\n/ {\n" + tab(1) + "keymap {\n" + tab(2) + "compatible = \"zmk,keymap\";\n\n"
	for i, layer := range layers {
		keymapString += tab(2) + layer.Identifier + " {\n"
		if layer.Label != "" {
			keymapString += tab(3) + "display-name = \"" + layer.Label + "\";\n"
		}
		if layer.Bindings != "" {
			keymapString += tab(3) + "bindings = <\n" + layer.Bindings + "\n" + tab(3) + ">;\n"
		}
		if layer.SensorBindings != "" {
			keymapString += tab(3) + "sensor-bindings = <" + layer.SensorBindings + ">;\n"
		}
		keymapString += tab(2) + "};\n"

		if i != len(layers)-1 {
			keymapString += "\n"
		}
	}
	keymapString += "\n"
	keymapString += tab(1) + "};\n};"

	return keymapString
}

type build struct {
	Board  string `json:"board"`
	Shield string `json:"shield"`
}

type buildMatrix struct {
	Include []build `json:"include"`
}

func GenerateBuildMatrix(shield, board string) string {
	validateShield(shield)

	adapterBytes, _ := fs.ReadFile("adapters/" + shield + ".yasui")
	adapterShields := extractYasuiSection(string(adapterBytes), "shields")

	shields := strings.Split(adapterShields, "\n")

	layout := make([]build, len(shields))
	for i, shield := range shields {
		layout[i] = build{board, shield}
	}

	buildMatrix := buildMatrix{layout}

	jsonBuildMatrix, _ := json.Marshal(buildMatrix)

	return (string(jsonBuildMatrix))
}
